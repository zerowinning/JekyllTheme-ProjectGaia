## 前言

程序员的编程技能随着经验的积累，会逐步提高。我认为编程能力可以分为一些层次。

下面通过两个维度展开编程能力层次模型的讨论。

一个维度是编程技能层次，另一个维度是领域知识层次。

## 编程技能层次

编程技能层次，指的程序员设计和编写程序的能力。这是程序员的根本。

### 0段—非程序员：

初学编程者，遇到问题，完全是懵懵懂懂，不知道该怎么编程解决问题。也就是说，还是门外汉，还不能称之为“程序员”。计算机在他面前还是一个神秘的黑匣子。

### 1段—基础程序员：

学习过一段时间编程后，接到任务，可以编写程序完成任务。

编写出来的代码，正常情况下是能够工作的，但在实际运行中，碰到一些特殊条件就会出现各类BUG。也就是说，具备了开发Demo软件的能力，但开发的软件真正交付给客户使用，恐怕会被客户骂死。

程序员程序是写好了，但到底为什么它有时能正常工作，有时又不行，程序员自己也不知道。

运行中遇到了bug，或者需求改变，需要修改代码或者添加代码，很快程序就变得结构混乱，代码膨胀，bug丛生。很快，就连最初的开发者自己也不愿意接手维护这个程序了。



### 2段—数据结构：

经过一段时间的编程实践后，程序员会认识到“数据结构 算法=程序”这一古训的含义。他们会使用算法来解决问题。进而，他们会认识到，算法本质上是依附于数据结构的，好的数据结构一旦设计出来，那么好的算法也会应运而生。

设计错误的数据结构，不可能生长出好的算法。

记得某一位外国先贤曾经说过：“给我看你的数据结构！”



### 3段—面向对象：

再之后，程序员就会领略面向对象程序设计的强大威力。大多数现代编程语言都是支持面向对象的。但并不是说，你使用面向对象编程语言编程，你用上了类，甚至继承了类，你就是在写面向对象的代码了。

我曾经见过很多用Java,Python,Ruby写的面向过程的代码。

只有你掌握了接口，掌握了多态，掌握了类和类，对象和对象之间的关系，你才真正掌握了面向对象编程技术。

就算你用的是传统的不支持面向对象的编程语言，只要你心中有“对象”，你依然可以开发出面向对象的程序。

如，我用C语言编程的时候，会有意识的使用面向对象的技巧来编写和设计程序。用struct来模拟类，把同一类概念的函数放在一起模拟类。如果你怀疑用C语言是否能编写出面向对象的代码，你可以看一下Linux内核，它是用C语言编写的，但你也可以看到它的源代码字里行间散发出的浓浓的“对象”的味道。

真正掌握面向对象编程技术并不容易。

在我的技术生涯中，有两个坎让我最感头疼。

一个坎是Dos向Windows开发的变迁过程中，框架的概念，很长一段时间我都理解不了。Dos时代，都是对函数库的调用，你的程序主动调用函数。Windows时代，则换成了框架。就算是你的main程序，其实也是被框架调用的。UI线程会从操作系统获取消息，然后发送给你的程序来处理。Java程序员熟悉的Spring框架，也是这样一个反向调用的框架。

现在因为“框架”这个术语显得很高大上，因此很多“类库”/“函数库”都自称为“框架”。在我看来这都是名称的滥用。

“类库”/“函数库”就是我写的代码调用它们。

“框架”就是我注册回调函数到框架，框架来调用我写的函数。

另一个坎就是面向对象。很长一段时间我都不知道应该怎么设计类和类之间的关系，不能很好的设计出类层次结构来。

我记得当时看到一本外国大牛的书，他讲了一个很简单、很实用的面向对象设计技巧：“叙述问题。然后把其中的名词找出来，用来构建类。把其中的动词找出来，用来构建类的方法”。虽然这个技巧挺管用的，但也太草根了点，没有理论依据，也不严谨。如果问题叙述的不好，那么获得的类系统就会是有问题的。

掌握面向对象思想的途径应该有很多种，我是从关系数据库中获得了灵感来理解和掌握面向对象设计思想的。

在我看来，关系数据库的表，其实就是一个类，每一行记录就是一个类的实例，也就是对象。表之间的关系，就是类之间的关系。O-Rmapping技术（如Hibernate），用于从面向对象代码到数据库表之间的映射，这也说明了类和表确实是逻辑上等价的。

既然数据库设计和类设计是等价的，那么要设计面向对象系统，只需要使用关系数据库的设计技巧即可。

关系数据库表结构设计是很简单的：

1、识别表和表之间的关系，也就是类和类之间的关系。是一对一，一对多，多对一，还是多对多。这就是类之间的关系。

2、识别表的字段。一个对象当然有无数多的属性（如，人：身高，体重，性别，年龄，姓名，身份证号，驾驶证号，银行卡号，护照号，港澳通行证号，工号，病史，婚史etc），我们写程序需要记录的只是我们关心的属性。这些关心的属性，就是表的字段，也就是类的属性。“弱水三千，我取一瓢饮”！



### 4段—设计模式：

曾经在网上看到这样一句话：“没有十万行代码量，就不要跟我谈什么设计模式”。深以为然。

记得第一次看Gof的设计模式那本书的时候，发现虽然以前并不知道设计模式，但在实际编程过程中，其实还是自觉使用了一些设计模式。设计模式是编程的客观规律，不是谁发明的，而是一些早期的资深程序员首先发现的。

不用设计模式，你也可以写出满足需求的程序来。但是，一旦后续需求变化，那么你的程序没有足够的柔韧性，将难以为继。而真实的程序，交付客户后，一定会有进一步的需求反馈。而后续版本的开发，也一定会增加需求。这是程序员无法回避的现实。

写UI程序，不论是Web,Desktop,Mobile,Game，一定要使用MVC设计模式。否则你的程序面对后续变化的UI需求，将无以为继。

设计模式，最重要的思想就是解耦，通过接口来解耦。这样，如果将来需求变化，那么只需要提供一个新的实现类即可。

主要的设计模式，其实都是面向对象的。因此，可以认为设计模式是面向对象的高级阶段。只有掌握了设计模式，才能认为是真正彻底掌握了面向对象设计技巧。

我学习一门新语言时（包括非面向对象语言，如函数式编程语言），总是会在了解了其语法后，看一下各类设计模式在这门语言中是如何实现的。这也是学习编程语言的一个窍门。



### 5段–语言专家：

经过一段时间的编程实践，程序员对某一种常用的编程语言已经相当精通了。有些人还成了“语言律师”，擅长向其他程序员讲解语言的用法和各种坑。

这一阶段的程序员，常常是自己所用语言的忠实信徒，常在社区和论坛上和其他语言的使用者争论哪一种语言是最好的编程语言。他们认为自己所用的语言是世界上最好的编程语言，没有之一。他们认为，自己所用的编程语言适用于所有场景。他们眼中，只有锤子，因此会把所有任务都当成是钉子。



### 6段–多语言专家：

这一个阶段的程序员，因为工作关系，或者纯粹是因为对技术的兴趣，已经学习和掌握了好几种编程语言。已经领略了不同编程语言不同的设计思路，对每种语言的长处和短处有了更多的了解。

他们现在认为，编程语言并不是最重要的，编程语言不过是基本功而已。

他们现在会根据不同的任务需求，或者不同的资源来选择不同的编程语言来解决问题，不再会因为没有使用某一种喜爱的编程语言开发而埋怨。

编程语言有很多种流派和思想，有一些编程语言同时支持多种编程范式。

#### 静态类型编程范式

采用静态类型编程范式的编程语言，其变量需要明确指定类型。代表语言：

C、C++、Pascal、Java、C#、Object-C、Golang、Swift、VB.net

#### 这样做的好处是：

1、编译器可以在编译时就能找出类型错误。

2、编译器编译时知道类型信息，就可以提高性能。

这种范式认为，程序员肯定知道变量的类型，你丫要是不知道变量的类型，那你就别混了！编译时，程序会报错。

Swift和Go语言都是静态类型编程语言，但它们都不需要明确指定类型，而是可以通过推断由编译器自动确定其类型。

#### 动态类型编程范式

采用静态类型编程范式的编程语言，其变量不需要明确指定类型。任意变量，可以指向任意类型的对象。代表语言：Python,Ruby,JavaScript。

动态类型的哲学可以用鸭子类型（英语：ducktyping）这个概念来概括。JamesWhitcombRiley提出的鸭子测试可以这样表述：“当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。”

这种范式认为，程序员肯定知道变量的类型和它支持的方法和属性，你丫要是不知道变量的类型，那你就别混了！运行时程序会崩溃！程序崩溃怨谁？怨你自己呗，你不是合格的程序员！

#### 动态类型的好处是：

不需要明确定义接口和抽象类型。只要一个类型支持需要的方法和属性，那么就OK。程序会相当灵活和简单。Java,C#视之为命脉的接口/基类，在动态语言这里都视如无物！

#### 缺点是：

1、如果类型不对，编译器也无法找到错误，而是运行时程序崩溃。

2、因为编译器不知道变量的类型，因此无法优化性能。

#### 面向对象编程范式

面向对象编程范式，从上世纪70年代末开始兴起。它支持类和类的实例作为封装代码的模块。代表语言：

Smalltalk、Pascal、Java、C#、Object-C、Golang、Swift、VB.net、Python、Ruby、ActionScript、OCaml

早期编程语言都是面向过程的。就是顺序，条件，循环，构成一个个函数。随着代码规模的增大，人们发现有必要对代码进行模块化。一个概念对应的代码放在一个文件中，这样便于并发开发和进行代码管理。

人们还发现了“程序=数据结构 算法”的规律。因此，一个概念对应的数据结构和函数应该放在一个文件中。这就是类的概念。

面向对象编程范式，确实极大地提高了生产效率，因此得到了广泛的应用，因此在语言层面支持面向对象编程范式的语言是极多的。

C语言尽管在语言层面上并不支持面向对象编程范式，但现代的C语言开发都会应用面向对象的模块化思想，把同一类的数据结构和函数放在一个文件中，采用类似的命名方式。

毕竟C语言没有在语言层面上支持面向对象，因此就有很多程序员想给C语言添加面向对象支持。其中的代表是C++和Objective-C。

C++是一种新的语言，但大部分语言元素是和C兼容的。

Objective-C是完全兼容的C的。Objective-C是给C添加了薄薄的一层语法糖以支持接口（就是其他语言的类）和协议（就是其他语言的接口）。甚至，Objective-C一开始的实现，就是一个C语言的预编译器。Objective-C坦白讲，除了添加的语法不太符合C流外，实际上其面向对象系统设计是相当精妙的。乔布斯早年慧眼识珠，把Objective-C收人囊中，因为封闭于Apple/NextStep系统内，因此少有人知。随着iOs系统的普及，Objective-C近几年才名满天下。

#### 函数式编程范式

函数式编程范式，是一些数学家发明的编程语言，他们认为程序就是数学函数嘛。代表语言：Lisp,Erlang,JavaScript,OCaml,Prog。

有很多大牛极力鼓吹过函数式编程语言，认为其极具革命性。但我认为他们过高估计了函数式编程范式的威力，我并不认为函数式编程范式相对于面向对象编程范式有何高明之处。

函数式编程语言，核心就是函数，它们没有Class类的概念。但它的函数又不是传统面向过程语言的函数，它的函数支持“闭包”的概念。

在我看来，函数式编程语言的函数，也就是“闭包”，说白了，其实就是“类”。编程语言发展到今天，就是需要模块化，就是需要把“数据结构”和“算法”结合起来。不论何种语言，不把它们结合起来的编程方式，都是没有出路的。

面向对象编程语言，用类把“数据结构”和“算法”结合起来。类的核心是“数据结构”，也就是其“属性”，而不是“算法”，其“函数”。在类中，是函数依附于属性。

而函数式编程语言，用闭包把“数据结构”和“算法”结合起来。是函数能够抓取外部的字段。是“属性”依附于“函数”。

“类”本质上和“闭包”是等价的。现在很多面向对象编程语言都加上了对闭包的支持。观察其代码，我们可以发现，它们实际上都是用“类”来实现“闭包”的。

“类”和“闭包”谁更易用？明显是“类”。

而“闭包”更简洁一些，因此“闭包”在面向对象编程语言中常用来替换匿名类。只有一个函数的类，写成一个类太麻烦，不如写成闭包，更加简洁。

吐槽一下OCaml语言，其前身Caml语言本身是一种挺好的函数式语言，硬生生添加了一套完整的面向对象机制，同时支持面向对象和函数式编程范式，很容易像C 一样脑裂的。

也有很多面向对象语言控看着JavaScript嫌烦，总是想把面向对象支持添加到JavaScript上。ActionScript就是其中一种尝试。我用过，真的是和Java没多少区别了。

再吐槽一下ExtJS。当初选型Web前端开发框架时比较了ExtJS和JQuery。

ExtJS明显是Java高手开发的，硬生生用JavaScript模拟Swing的设计思想，搞了一套UI库。

JQuery开发者明显是领悟了JavaScript的函数式编程范式，依据JavaScript的动态函数式编程语言的特点打造了一套UI库，立刻秒杀ExtJS。

由ExtJS和JQuery的故事，我们可以看到多语言编程能力是多么的重要。ExtJS的作者精通并喜爱Java，因此他把手术刀JavaScript当做锤子Java使，一通乱敲，费力不讨好。

函数式编程语言，还有尾递归等一些小技巧。尾递归可以不用栈，防止递归调用时栈溢出。

#### 模板编程范式

模板编程，就是把类型作为参数，一套函数可以支持任意多种类型。代表语言：C 。

模板编程的需求，是在C 开发容器库的时候发明的。因为容器需要保存任意类型的对象，因此就有了泛型的需求。

C 的模板编程，是在编译时，根据源码中的使用情况，创建对应类型的代码。除了C 这种方式，Java，C#也有类似的机制，叫做“泛型”，但它们的实现方式和C 的模板很不同。它们的编译器不会生成新的代码，而是使用强制类型转换的方式实现。

在没有模板/泛型的编程语言中，怎样在容器中存放对象呢？存取公共基类类型（Java,C#）的对象，或者void*指针（C）即可，取出时自己强制类型转换为实际类型。动态类型语言，不关心类型，更是无所谓了，随便什么对象直接往容器里扔进去，取出来直接用即可。

一些C 高手又在模板的基础上搞出了“模板元编程”。因为模板编程，就是C 的编译器搞定的嘛，模板元编程就是让编译器运算，编译完结果也就算出来了。我不知道除了研究和炫技，这玩意有啥用？

### 小结

#### 一门语言是否值得学习，我认为有几个标准：

1、是否要用，要用就得学，这么没有疑问的。毕竟我们都要吃饭的嘛。

2、其语言特性是否给你耳目一新的感觉。如果是，那就值回票价了。如Go语言废掉了异常，改用返回多值。我深以为然。我其实已经主动不用异常好多年了。因为，我觉得既然C不支持异常也活得很好，为什么需要异常呢？出错了，返回错误码。无法挽回的错误，直接Abort程序就可以嘛！而且，异常实际上是违反面向过程编程原则的。一个函数应该只有一个入口一个出口。抛出异常就多了出口了。

3、是否擅长某一个领域。如果你手里只有一把锤子，那么你就只能把所有任务都当做钉子猛锤一通。但如果工具箱里有多种工具，那面对不同的任务就得心应手多了。



### 7段—架构设计

还需要掌握架构设计的能力，才能设计出优秀的软件。架构设计有一些技巧：

#### 1、分层

一个软件通常分为：

表现层–UI部分

接口层–后台服务的通讯接口部分

服务层–实际服务部分

存储层—持久化存储部分，存储到文件或者数据库。

分层的软件，可以解耦各个模块，支持并行开发，易于修改，易于提升性能。

#### 2、SOA

模块之间通过网络通讯互相连接，松耦合。每一个模块可以独立部署，可以增加部署实例从而提高性能。每一个模块可以使用不同的语言和平台开发，可以重用之前开发的服务。SOA，常用协议有WebService,REST,JSON-RPC等。

#### 3、性能瓶颈

1）化同步为异步。

用内存队列（Redis），工作流引擎（JBpm）等实现。内存队列容易丢失数据，但是速度快。工作流引擎会把请求保存到数据库中。

通过化同步请求为异步请求，基本上99.99%的性能问题都可以解决。

2）用单机并行硬件处理。

如，使用GPU，FPGA等硬件来处理，提高性能。

3）用集群计算机来处理。

如，Hadoop集群，用多台计算机来并行处理数据。

自己的软件栈中，也可以把一个模块部署多份，并行处理。

4）用cache来满足请求。常用的内容加热cache后，大量的用户请求都只是内存读取数据而已，性能会得到很大的提升。

cache是上帝算法，记得好像它的性能只比最佳性能低一些，就好像你是上帝，能够预见未来一样。现在X86CPU遇到了主频限制，CPU提升性能的主要途径就是增加高速Cache了。

#### 4、大系统小做

遇到大型系统不要慌，把它切分成多个模块，用多个小程序，通过SOA协作来解决。这秉承了Unix的设计思想。Unix上开发了大量单一目的的小程序，它主张用户通过管道来让多个小程序协作，解决用户的需求。当然，管道方式通讯限制太多，不够灵活。因此，现在我们可以通过URI,通过SOA的方式来让多个程序协作。Andorid和iOS上的应用程序，现在都是通过URI实现协作的。这也算是Unix设计思想的现代发展吧？！

#### 5、Sharding切片

现在有一个潮流，就是去IOE。I-IBM大型机，O-Oracle数据库，E-EMC存储。之前，大型系统常用IOE去架构，在大型机上部署一个Oracle数据库，Oracle数据库用EMC存储保存数据。IOE是当今最强的计算机，数据库和存储。但他们面对海量系统也有抗不住的一天。

Oracle数据库是Shareeverything的，它可以在一个计算机集群（服务器节点不能超过16个）上运行。计算机集群都共用一个存储。

去IOE运动，标志着ShareEverything模式的破产。必须使用ShareNothing，系统才能无限扩展。

用MySQL数据库就可以应付任意规模的数据了。前提是，你会Sharding分片。把大系统切分成若干个小系统，切分到若干台廉价服务器和存储上。更Modern一些，就是切分到大量虚拟机上。

如，铁道部的12306网站。我们知道火车票都是从属于某一列列车的。那么我们把每一个列车作为一个单元来切分，就可以把12306网站切分成几千个模块。一台虚拟机可以承载若干个模块。当某些列车成为性能瓶颈之后，就可以把它们迁移到独立的虚拟机上。即使最终有部分列出服务不可用，系统也不会完全不可用。

12306网站，只有一个全局的部分，就是用户登录。这个可以交给第三方负责。如可以让用户用微信，微博，qq等账户登录。

也可以自己实现用户登录服务。还是用切片的方式用多台Redis服务器提供服务。Redis服务器存储每一个登录用户的sessionId和userId，角色，权限等信息。sessionId是随机生成的，可选择其部分bit用于标识它在哪一个Redis服务器上。用户登录后，把sessionId发给客户。用户每次请求时把sessionId发回给服务器。服务器把sessionId发给Redis服务器查询得到其用户信息，对用户请求进行处理。如果在redis服务器上找不到sessionId，则让用户去登录。即使所有注册用户同时登陆，也不需要太多的内存。而且，可以在session内存过多时，删除最早登陆的用户的session，强制他再次登陆。同时活跃的用户数不会太多。


## 领域知识层次

前面的所有层次，都是关注编程本身的技能，说白了，就是基本功，本身并不能产生太大的价值。但有太多的程序员浪费太多的时间在那些筑基的层次上。

有些程序员特别喜欢钻研编程语言，每有一种新的编程语言出来或者旧语言被热炒，就会投入精力进去研究。我就是其中之一，浪费了很多精力在编程语言上，在奇技淫巧上。

我觉得C++语言是一个特别大的坑。刚开始是作为面向对象的C被开发的。后来发现了模板编程，就大力鼓吹模板编程和进一步的模板元编程。最近又推出了新标准，进一步添加了很多新东西，函数式编程，类型推断等，过分复杂，太多的坑消耗了大量程序员的大量精力。我使用C++时，只使用面向对象部分和模板部分，其他过于精深的特性都不使用。

计算机科学是一个面相当广泛的学科，有很多领域知识需要和值得我们深入研究，我们才能写出有价值的程序来。软件必须要和行业结合起来，要落地才有价值。仅仅研究编程技巧，不懂领域知识是写不出有价值的程序的。



### 计算机科学领域有很多，列举一些如下：

存储—-块设备，文件系统，集群文件系统，分布式文件系统，光纤SCSI，iSCSI，RAID等。
网络—-以太网，光纤网，蜂窝网络，WIFI，VLAN等。
计算机体系结构，主要就是CPU指令集。x86,ARM等。
USB协议。需要知道URB包。
PCI协议，PCI-E协议。现代计算机的外设都是PCI协议和PCI-E协议的。显卡现在全是通过 PCI-E协议连接到计算机上的。相对来说减少了很多需要学习的知识。搞虚拟化就需要深入掌握PCI协议。
图像处理–图像压缩，视频实时编码等。
3D游戏
关系数据库
NoSQL数据库
操作系统
分布式操作系统
编译原理
机器学习–现在大数据要用哦！
了解这些领域知识，也包括了解该领域现有的商用硬件、商用软件和开源软件。很多时候，你要完成的工作，已经有现成的工具了。你只要使用现成的工具就可以完成任务，不需要进行开发。有时候，只需要组合现有的工具，写一些脚本就可以完成任务。

如，我一次要实现一个双向同步任务。找到了一个优秀的开源软件Unison，编写一下配置文件就圆满地完成了任务。不需要编写任何代码。

还有一次，要做高可用，用Python调用了几个开源软件就轻松实现了。

编写安装程序，定制操作系统，知道了操作系统的领域知识，写几行脚本就可以轻松搞定。

不具备领域知识的人，就可能不得不进行大量无谓的开发，甚至开发很久之后才发现，这根本就是一条死路。

另外，扎实的领域知识，可以大大提高编程调试、查错的能力。知道编译器和编程语言运行时工作原理，就能快速根据编译错误和警告信息修改代码。

知道操作系统底层运行机制，就能快速找到运行时错误的问题根源。如，有一次我编写一个windows升级服务程序。它是一个windows服务，需要执行dos脚本，这个脚本会替换掉这个windows服务本身。发现有时脚本执行无效，查了一晚上，发现当windows服务安装后，第一次启动就执行脚本时就会有权限问题，log都正确，但实际执行这个脚本没有任何效果。但一旦windows服务程序启动一次之后就ok。这必然是windows操作系统底层安全机制的问题，因为我对Windows内核了解不多，因此花了很长时间才发现这个问题，并对造成这个问题的根源并不清楚。

### 0段—领域知识菜鸟

对领域知识没有多少认知，通过搜索引擎找到一些该领域的软件和硬件的介绍性文章，按照文章指示配置和使用软件。勉强能够使用现有软硬件。

### 1段—领域知识行家

了解领域内常用硬件，深入掌握领域内常用软件的配置和使用技巧。能够使用现有软硬件熟练搭建解决方案，能够解决实际工作中遇到的种种问题。

### 2段—领域知识专家

当你不仅仅掌握了该领域的软件和工具，知道怎么用，还知道其原理，“知其然，也知其所以然”，就是该领域的知识专家了。

你知道网络协议的原理，你才能在网络出现问题时知道是哪里可能出现了问题。是mac冲突，ip冲突，还是网络环路？

你知道存储的原理，你才能知道为什么这种存储方式不适合虚拟化，那种存储方式适合虚拟化，另一种方式适合资料备份。

你知道PCI协议，你才能知道你怎样才能虚拟化一个硬件设备。

你知道网卡硬件协议，你才能模拟出一个虚拟机能正常使用的虚拟网卡。

你知道视频编码格式和原理，才能知道什么视频格式占用带宽最少，什么视频格式占用CPU最少。

你了解IntelVT/Amd V指令集，才能知道虚拟化是怎样实现的。

你明白工作流其实就是状态机，在遇到复杂工作流程时，你才能知道怎样设计满足要求的工作流引擎。

### 3段—科学家

你是领域知识专家，但你的知识都是来自于书本，来自于其他人的。

如果你满足于当领域知识专家，你只能拾人牙慧，永远别想超越。别人的研究成果，未必愿意告诉你。当别人告诉你的时候，它可能已经发现了更新的理论，并且新一代产品可能马上就要发布了。

科学家是探索未知，勇于创新的人，是推动人类社会进步的人。

传说，思科的一位高管曾经半开玩笑地说过：“如果思科停止了新技术的研发，华为就会找不着方向”。这是在嘲笑华为只是处在领域知识专家的水平，只能山寨无法超越。我不知道华为的实际情况，但希望现在的华为已经走到了领跑者的位置。

欧文·雅各布斯发现了CDMA码分多址的原理，并发现它在通讯上大有可为，组建了高通公司。高通公司主要以专利授权费为生，它雇佣了大量科学家在通讯领域展开研究。有人说高通是专利流氓。这些人不明白知识的价值。在他们眼里，Windows的合理价格就应该是5元钱，一张光盘的价格。iPhone就应该是1000多元裸机的价格。高通是专利流氓，那你也流氓一个CDMA，LTE出来给我看看！

X86芯片在设计上没有考虑虚拟化。因此会有所谓的“虚拟化漏洞”出现。就是说，一些CPU特权指令执行时，在虚拟机环境下不会抛出异常，因此就无法切换到Host。这样，X86芯片上就无法运行虚拟机。

VmWare公司是由美国的几位科学家在1998年创建的。他们发现可以使用二进制翻译的技术，在X86计算机上运行虚拟机。

Xen虚拟化软件也是几位科学家发明的。他们发现只要修改虚拟机操作系统和Host操作系统的内核，在需要执行“虚拟化漏洞”指令时直接调用Host的功能，就可以实现虚拟化，而且大大提高了虚拟机的运行性能。

后来，Intel为自己的芯片添加了IntelVT指令集，Amd为自己的芯片添加了AmdV指令集，弥补了“虚拟化漏洞”。于是就有了KVM虚拟机软件，它直接用CPU硬件指令实现虚拟化。

KVM在执行CPU指令时，是直接在物理CPU上运行的，因此效率极高。但是，虚拟机运行虚拟外设时，就必须用软件模拟，因此虚拟机的IO访问速度很慢。

IBM科学家RustyRussell，借鉴了Xen的研发经验，创建了VirtIO技术。就是在虚拟机中编写一套PCI虚拟设备和驱动，这套虚拟PCI设备有一块虚拟设备内存。这个虚拟设备内存Host是可以访问的，虚拟机通过VirtIO驱动程序也可以访问。也就是一块内存在虚拟机和Host中共享，这就解决了虚拟机的IO性能问题。

### 再讲一个搜索引擎的故事：

很久以前，我要给一个程序添加搜索功能。刚开始使用sql查询实现，发现实在太慢了。后来找了开源的Lucene项目。它使用反向索引技术，通过在文件中创建反向索引，大大提高了搜索速度。

Google的两位创始人发现了html中link的秘密，他们发现可以通过html页面的link关系来为每一个html页面设置权重。也就是PageRank算法。于是，Google的自动搜索引擎击败了Yahoo人工分类的搜索引擎。

OK，利用反向索引技术和PageRank，以及一个简单的html爬虫机器人，我们就可以创建一个搜索引擎了。但是，互联网很大，每天产生大量新网页，要为整个互联网建立反向索引是很困难的。

若干年后Google又公开了三篇论文：Googlefs、Mapreduce、Bigtable。于是Lucene项目的开发者根据Google的Mapreduce论文开发了Hadoop项目。MapReduce就是使用大量计算机存储数据并计算，最后汇总结果。使用Hadoop 反向索引 PageRank，就可以创建搜索引擎了。Yahoo,Baidu等公司纷纷基于Hadoop开发了自己的搜索引擎。

但是，其他公司的搜索引擎效果还是没法和Google相比。这一点我们程序员最清楚。像我，就总是翻蔷出去，只为了Google一下。

Google黑板报上发表了吴军博士的一些文章，其中介绍了很多机器学习方面的知识。从文中可以知道，Google其实使用机器学习来分析搜集到的页面。Google明显不会把这个公式公开出来。即使有一天Google真的公开了这个公式，那么可以想见Google肯定又研发出了更加犀利的秘籍，山寨货的搜索引擎效果还是比不上Google的。

山寨是通向创新的必由之路。在成为领域的领头羊和领导者之前，必然要经过学习，模仿的阶段。但要成为行业的老大，成为Champion，必须勇于弯道超车，勇敢地走上创新之路，成为真正的科学家，真正的大牛！



### 总结

编程能力可分为两个维度：一个是编程技能水平，另一个是领域知识水平。

有些程序员可能把精力都花在提升编程技能上了，领域知识知之甚少，这其实在日常工作中也是极其有害的。有些需求可能早已经有了现成、开源免费的解决方案，或者只需要组合几个现有软件就可以快速搞定，而他们却不得不自己花大量时间去开发。另外，缺少领域知识，在程序出现非预期状况时，很难快速定位到问题的根源，很难解决bug。